{
  "address": "0xB85F2463b18c4065eE9135214eA2D0F9fD9954f4",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_futarchyRouter",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_swaprRouter",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_balancerVault",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "tokenOut",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "profit",
          "type": "uint256"
        }
      ],
      "name": "ArbitrageExecuted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "companyTokensOut",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "sdaiOut",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "profit",
          "type": "uint256"
        }
      ],
      "name": "ConditionalArbitrageExecuted",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "balancerVault",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "proposalAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiYesToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiNoToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyYesToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyNoToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amountIn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minProfit",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "balancerSwapData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "swaprYesSwapData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "swaprNoSwapData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.ConditionalArbitrageParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "executeBuyConditionalArbitrage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "profit",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "proposalAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiYesToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiNoToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyYesToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyNoToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amountIn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minProfit",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "balancerSwapData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "swaprYesSwapData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "swaprNoSwapData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.ConditionalArbitrageParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "executeSellConditionalArbitrage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "profit",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "futarchyRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rescueETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "rescueToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "proposalAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiYesToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiNoToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyYesToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyNoToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amountIn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minProfit",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "balancerSwapData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "swaprYesSwapData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "swaprNoSwapData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.ConditionalArbitrageParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "simulateBuyConditional",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "expectedProfit",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "profitable",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "proposalAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiYesToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sdaiNoToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyYesToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "companyNoToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amountIn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minProfit",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "balancerSwapData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "swaprYesSwapData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "swaprNoSwapData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.ConditionalArbitrageParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "simulateSellConditional",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "expectedProfit",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "profitable",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "swaprRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "tx_hash": "0xc3d70cbd86583872d25e63618c9a5305c18750145f0f7d7a2b72bbab85480e22",
  "block_number": 41045283,
  "deployer": "0x91c612a37b8365C2db937388d7b424fe03D62850",
  "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n\ninterface IFutarchyRouter {\n    function splitPosition(address proposal, address collateralToken, uint256 amount) external;\n    function mergePositions(address proposal, address collateralToken, uint256 amount) external;\n}\n\ninterface ISwaprRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    \n    function exactInputSingle(ExactInputSingleParams calldata params) external returns (uint256 amountOut);\n}\n\ninterface IBalancerVault {\n    struct SingleSwap {\n        bytes32 poolId;\n        uint8 kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n    \n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n    \n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external returns (uint256);\n}\n\ncontract FutarchyArbitrageExecutor {\n    address public immutable owner;\n    address public immutable futarchyRouter;\n    address public immutable swaprRouter;\n    address public immutable balancerVault;\n    \n    uint256 private constant MAX_UINT = type(uint256).max;\n    uint256 private constant DEADLINE_BUFFER = 300; // 5 minutes\n    \n    struct ArbitragePath {\n        address tokenIn;\n        address tokenOut;\n        address[] intermediateTokens;\n        bytes[] swapData;\n        uint256 amountIn;\n        uint256 minAmountOut;\n    }\n    \n    struct ConditionalArbitrageParams {\n        address proposalAddress;\n        address sdaiToken;\n        address companyToken;\n        address sdaiYesToken;\n        address sdaiNoToken;\n        address companyYesToken;\n        address companyNoToken;\n        uint256 amountIn;\n        uint256 minProfit;\n        bytes balancerSwapData;\n        bytes swaprYesSwapData;\n        bytes swaprNoSwapData;\n    }\n    \n    event ArbitrageExecuted(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 profit\n    );\n    \n    event ConditionalArbitrageExecuted(\n        uint256 amountIn,\n        uint256 companyTokensOut,\n        uint256 sdaiOut,\n        uint256 profit\n    );\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can execute\");\n        _;\n    }\n    \n    constructor(\n        address _owner,\n        address _futarchyRouter,\n        address _swaprRouter,\n        address _balancerVault\n    ) {\n        require(_owner != address(0), \"Invalid owner\");\n        require(_futarchyRouter != address(0), \"Invalid futarchy router\");\n        require(_swaprRouter != address(0), \"Invalid swapr router\");\n        require(_balancerVault != address(0), \"Invalid balancer vault\");\n        \n        owner = _owner;\n        futarchyRouter = _futarchyRouter;\n        swaprRouter = _swaprRouter;\n        balancerVault = _balancerVault;\n    }\n    \n    function executeBuyConditionalArbitrage(\n        ConditionalArbitrageParams calldata params\n    ) external onlyOwner returns (uint256 profit) {\n        // Pull sDAI from owner\n        IERC20(params.sdaiToken).transferFrom(owner, address(this), params.amountIn);\n        \n        uint256 initialBalance = IERC20(params.sdaiToken).balanceOf(address(this));\n        \n        // Step 1: Split sDAI into conditional tokens\n        _approveIfNeeded(params.sdaiToken, futarchyRouter, params.amountIn);\n        IFutarchyRouter(futarchyRouter).splitPosition(params.proposalAddress, params.sdaiToken, params.amountIn);\n        \n        // Step 2: Swap conditional sDAI to conditional Company tokens on Swapr\n        uint256 yesBalance = IERC20(params.sdaiYesToken).balanceOf(address(this));\n        uint256 noBalance = IERC20(params.sdaiNoToken).balanceOf(address(this));\n        \n        // Swap YES tokens\n        _approveIfNeeded(params.sdaiYesToken, swaprRouter, yesBalance);\n        uint256 companyYesOut = _executeSwaprSwap(\n            params.sdaiYesToken,\n            params.companyYesToken,\n            yesBalance,\n            params.swaprYesSwapData\n        );\n        \n        // Swap NO tokens\n        _approveIfNeeded(params.sdaiNoToken, swaprRouter, noBalance);\n        uint256 companyNoOut = _executeSwaprSwap(\n            params.sdaiNoToken,\n            params.companyNoToken,\n            noBalance,\n            params.swaprNoSwapData\n        );\n        \n        // Step 3: Merge conditional Company tokens\n        uint256 mergeAmount = companyYesOut < companyNoOut ? companyYesOut : companyNoOut;\n        _approveIfNeeded(params.companyYesToken, futarchyRouter, mergeAmount);\n        _approveIfNeeded(params.companyNoToken, futarchyRouter, mergeAmount);\n        IFutarchyRouter(futarchyRouter).mergePositions(params.proposalAddress, params.companyToken, mergeAmount);\n        \n        // Step 4: Handle imbalances (liquidate excess conditional tokens)\n        if (companyYesOut > mergeAmount) {\n            // Excess YES tokens - swap back to sDAI\n            uint256 excessYes = companyYesOut - mergeAmount;\n            _approveIfNeeded(params.companyYesToken, swaprRouter, excessYes);\n            _executeSwaprSwap(\n                params.companyYesToken,\n                params.sdaiToken,\n                excessYes,\n                params.swaprYesSwapData\n            );\n        } else if (companyNoOut > mergeAmount) {\n            // Excess NO tokens - swap back to sDAI\n            uint256 excessNo = companyNoOut - mergeAmount;\n            _approveIfNeeded(params.companyNoToken, swaprRouter, excessNo);\n            _executeSwaprSwap(\n                params.companyNoToken,\n                params.sdaiToken,\n                excessNo,\n                params.swaprNoSwapData\n            );\n        }\n        \n        // Step 5: Sell Company tokens on Balancer\n        uint256 companyBalance = IERC20(params.companyToken).balanceOf(address(this));\n        _approveIfNeeded(params.companyToken, balancerVault, companyBalance);\n        uint256 sdaiOut = _executeBalancerSwap(\n            params.companyToken,\n            params.sdaiToken,\n            companyBalance,\n            params.balancerSwapData\n        );\n        \n        // Calculate profit and verify minimum\n        uint256 finalBalance = IERC20(params.sdaiToken).balanceOf(address(this));\n        profit = finalBalance > initialBalance ? finalBalance - initialBalance : 0;\n        require(profit >= params.minProfit, \"Insufficient profit\");\n        \n        // Transfer all sDAI back to owner\n        IERC20(params.sdaiToken).transfer(owner, finalBalance);\n        \n        emit ConditionalArbitrageExecuted(params.amountIn, mergeAmount, sdaiOut, profit);\n    }\n    \n    function executeSellConditionalArbitrage(\n        ConditionalArbitrageParams calldata params\n    ) external onlyOwner returns (uint256 profit) {\n        // Pull Company tokens from owner\n        IERC20(params.companyToken).transferFrom(owner, address(this), params.amountIn);\n        \n        uint256 initialSdaiBalance = IERC20(params.sdaiToken).balanceOf(owner);\n        \n        // Step 1: Buy sDAI with Company tokens on Balancer\n        _approveIfNeeded(params.companyToken, balancerVault, params.amountIn);\n        uint256 sdaiOut = _executeBalancerSwap(\n            params.companyToken,\n            params.sdaiToken,\n            params.amountIn,\n            params.balancerSwapData\n        );\n        \n        // Step 2: Split Company tokens into conditional tokens\n        _approveIfNeeded(params.companyToken, futarchyRouter, params.amountIn);\n        IFutarchyRouter(futarchyRouter).splitPosition(params.proposalAddress, params.companyToken, params.amountIn);\n        \n        // Step 3: Swap conditional Company tokens to conditional sDAI on Swapr\n        uint256 companyYesBalance = IERC20(params.companyYesToken).balanceOf(address(this));\n        uint256 companyNoBalance = IERC20(params.companyNoToken).balanceOf(address(this));\n        \n        // Swap YES tokens\n        _approveIfNeeded(params.companyYesToken, swaprRouter, companyYesBalance);\n        uint256 sdaiYesOut = _executeSwaprSwap(\n            params.companyYesToken,\n            params.sdaiYesToken,\n            companyYesBalance,\n            params.swaprYesSwapData\n        );\n        \n        // Swap NO tokens\n        _approveIfNeeded(params.companyNoToken, swaprRouter, companyNoBalance);\n        uint256 sdaiNoOut = _executeSwaprSwap(\n            params.companyNoToken,\n            params.sdaiNoToken,\n            companyNoBalance,\n            params.swaprNoSwapData\n        );\n        \n        // Step 4: Merge conditional sDAI tokens\n        uint256 mergeAmount = sdaiYesOut < sdaiNoOut ? sdaiYesOut : sdaiNoOut;\n        _approveIfNeeded(params.sdaiYesToken, futarchyRouter, mergeAmount);\n        _approveIfNeeded(params.sdaiNoToken, futarchyRouter, mergeAmount);\n        IFutarchyRouter(futarchyRouter).mergePositions(params.proposalAddress, params.sdaiToken, mergeAmount);\n        \n        // Step 5: Handle imbalances\n        if (sdaiYesOut > mergeAmount) {\n            // Excess YES tokens - keep as sDAI\n            uint256 excessYes = sdaiYesOut - mergeAmount;\n            // Already in sDAI form, just transfer\n        } else if (sdaiNoOut > mergeAmount) {\n            // Excess NO tokens - keep as sDAI\n            uint256 excessNo = sdaiNoOut - mergeAmount;\n            // Already in sDAI form, just transfer\n        }\n        \n        // Calculate final balance and profit\n        uint256 finalSdaiBalance = IERC20(params.sdaiToken).balanceOf(address(this));\n        uint256 totalSdaiOut = finalSdaiBalance + sdaiOut;\n        \n        // Verify minimum profit\n        require(totalSdaiOut > params.amountIn + params.minProfit, \"Insufficient profit\");\n        profit = totalSdaiOut - params.amountIn;\n        \n        // Transfer all sDAI to owner\n        IERC20(params.sdaiToken).transfer(owner, finalSdaiBalance);\n        \n        emit ConditionalArbitrageExecuted(params.amountIn, params.amountIn, totalSdaiOut, profit);\n    }\n    \n    function _executeSwaprSwap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        bytes calldata swapData\n    ) private returns (uint256) {\n        // Decode swap parameters from swapData\n        (uint24 fee, uint256 amountOutMinimum) = abi.decode(swapData, (uint24, uint256));\n        \n        ISwaprRouter.ExactInputSingleParams memory params = ISwaprRouter.ExactInputSingleParams({\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            fee: fee,\n            recipient: address(this),\n            deadline: block.timestamp + DEADLINE_BUFFER,\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMinimum,\n            sqrtPriceLimitX96: 0\n        });\n        \n        return ISwaprRouter(swaprRouter).exactInputSingle(params);\n    }\n    \n    function _executeBalancerSwap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        bytes calldata swapData\n    ) private returns (uint256) {\n        // Decode swap parameters\n        (bytes32 poolId, uint256 minAmountOut) = abi.decode(swapData, (bytes32, uint256));\n        \n        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault.SingleSwap({\n            poolId: poolId,\n            kind: 0, // GIVEN_IN\n            assetIn: tokenIn,\n            assetOut: tokenOut,\n            amount: amountIn,\n            userData: \"\"\n        });\n        \n        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: payable(address(this)),\n            toInternalBalance: false\n        });\n        \n        return IBalancerVault(balancerVault).swap(\n            singleSwap,\n            funds,\n            minAmountOut,\n            block.timestamp + DEADLINE_BUFFER\n        );\n    }\n    \n    function _approveIfNeeded(address token, address spender, uint256 amount) private {\n        uint256 currentAllowance = IERC20(token).allowance(address(this), spender);\n        if (currentAllowance < amount) {\n            // Reset approval to 0 first for tokens that require it\n            if (currentAllowance > 0) {\n                IERC20(token).approve(spender, 0);\n            }\n            IERC20(token).approve(spender, MAX_UINT);\n        }\n    }\n    \n    // View functions for simulation\n    function simulateBuyConditional(\n        ConditionalArbitrageParams calldata params\n    ) external view returns (uint256 expectedProfit, bool profitable) {\n        // This would be called via eth_call to simulate the arbitrage\n        // Returns expected profit without executing\n        // Implementation would mirror the execution logic but with calculations only\n        return (0, false); // Placeholder\n    }\n    \n    function simulateSellConditional(\n        ConditionalArbitrageParams calldata params\n    ) external view returns (uint256 expectedProfit, bool profitable) {\n        // This would be called via eth_call to simulate the arbitrage\n        // Returns expected profit without executing\n        return (0, false); // Placeholder\n    }\n    \n    // Emergency functions\n    function rescueToken(address token, uint256 amount) external onlyOwner {\n        IERC20(token).transfer(owner, amount);\n    }\n    \n    function rescueETH() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n    \n    // Receive ETH\n    receive() external payable {}\n}",
  "constructor_args": {
    "owner": "0x91c612a37b8365C2db937388d7b424fe03D62850",
    "futarchy_router": "0x7495a583ba85875d59407781b4958ED6e0E1228f",
    "swapr_router": "0xfFB643E73f280B97809A8b41f7232AB401a04ee1",
    "balancer_vault": "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
  }
}