{
  "address": "0xf276e5d62978F0E79089a4B7867A2AD97E3c9be5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "profit",
          "type": "uint256"
        }
      ],
      "name": "ArbitrageProfit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "callsCount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "successCount",
          "type": "uint256"
        }
      ],
      "name": "MulticallExecuted",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "spenders",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "batchApprove",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.Call[]",
          "name": "calls",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "profitToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minProfit",
          "type": "uint256"
        }
      ],
      "name": "executeArbitrage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "profit",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.Call[]",
          "name": "calls",
          "type": "tuple[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            },
            {
              "internalType": "bytes",
              "name": "returnData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.Result[]",
          "name": "returnData",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.Call[]",
          "name": "calls",
          "type": "tuple[]"
        }
      ],
      "name": "multicallStrict",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "returnData",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "pullToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "pushToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rescueETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "rescueToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "simulateCall",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.Call[]",
          "name": "calls",
          "type": "tuple[]"
        }
      ],
      "name": "simulateMulticall",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "success",
              "type": "bool"
            },
            {
              "internalType": "bytes",
              "name": "returnData",
              "type": "bytes"
            }
          ],
          "internalType": "struct FutarchyArbitrageExecutor.Result[]",
          "name": "results",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "tx_hash": "0xbbe728f023fc60252801dda910fd793e9cb6f9c80c76bedbb62e20effc972631",
  "block_number": 41045624,
  "deployer": "0x91c612a37b8365C2db937388d7b424fe03D62850",
  "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n\ncontract FutarchyArbitrageExecutor {\n    address public immutable owner;\n    \n    uint256 private constant MAX_UINT = type(uint256).max;\n    \n    struct Call {\n        address target;\n        bytes callData;\n    }\n    \n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n    \n    event MulticallExecuted(\n        uint256 callsCount,\n        uint256 successCount\n    );\n    \n    event ArbitrageProfit(\n        address indexed token,\n        uint256 profit\n    );\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can execute\");\n        _;\n    }\n    \n    constructor(address _owner) {\n        require(_owner != address(0), \"Invalid owner\");\n        owner = _owner;\n    }\n    \n    /**\n     * @notice Execute multiple calls in a single transaction\n     * @param calls Array of Call structs containing target addresses and calldata\n     * @return returnData Array of Result structs containing success status and return data\n     */\n    function multicall(Call[] calldata calls) external onlyOwner returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        uint256 successCount = 0;\n        \n        for (uint256 i = 0; i < length; i++) {\n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n            returnData[i] = Result(success, ret);\n            if (success) successCount++;\n        }\n        \n        emit MulticallExecuted(length, successCount);\n    }\n    \n    /**\n     * @notice Execute multiple calls, reverting if any fail\n     * @param calls Array of Call structs containing target addresses and calldata\n     * @return returnData Array of return data from each call\n     */\n    function multicallStrict(Call[] calldata calls) external onlyOwner returns (bytes[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n            require(success, string(abi.encodePacked(\"Call \", _toString(i), \" failed\")));\n            returnData[i] = ret;\n        }\n        \n        emit MulticallExecuted(length, length);\n    }\n    \n    /**\n     * @notice Execute arbitrage operations and calculate profit\n     * @param calls Array of Call structs for the arbitrage operations\n     * @param profitToken The token to measure profit in\n     * @param minProfit Minimum profit required (transaction reverts if not met)\n     */\n    function executeArbitrage(\n        Call[] calldata calls,\n        address profitToken,\n        uint256 minProfit\n    ) external onlyOwner returns (uint256 profit) {\n        // Record initial balance\n        uint256 initialBalance = IERC20(profitToken).balanceOf(address(this));\n        \n        // Execute all calls\n        uint256 length = calls.length;\n        for (uint256 i = 0; i < length; i++) {\n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n            require(success, string(abi.encodePacked(\"Arbitrage call \", _toString(i), \" failed: \", _getRevertMsg(ret))));\n        }\n        \n        // Calculate profit\n        uint256 finalBalance = IERC20(profitToken).balanceOf(address(this));\n        profit = finalBalance > initialBalance ? finalBalance - initialBalance : 0;\n        \n        require(profit >= minProfit, \"Insufficient profit\");\n        \n        // Transfer profit to owner\n        if (profit > 0) {\n            IERC20(profitToken).transfer(owner, profit);\n            emit ArbitrageProfit(profitToken, profit);\n        }\n        \n        // Transfer any remaining balance\n        uint256 remainingBalance = IERC20(profitToken).balanceOf(address(this));\n        if (remainingBalance > 0) {\n            IERC20(profitToken).transfer(owner, remainingBalance);\n        }\n    }\n    \n    /**\n     * @notice Approve tokens for multiple spenders\n     * @param tokens Array of token addresses\n     * @param spenders Array of spender addresses\n     * @param amounts Array of amounts to approve (use MAX_UINT for unlimited)\n     */\n    function batchApprove(\n        address[] calldata tokens,\n        address[] calldata spenders,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        require(tokens.length == spenders.length && tokens.length == amounts.length, \"Array length mismatch\");\n        \n        for (uint256 i = 0; i < tokens.length; i++) {\n            _approveIfNeeded(tokens[i], spenders[i], amounts[i]);\n        }\n    }\n    \n    /**\n     * @notice Transfer tokens from owner to contract\n     * @param token Token address\n     * @param amount Amount to transfer\n     */\n    function pullToken(address token, uint256 amount) external onlyOwner {\n        IERC20(token).transferFrom(owner, address(this), amount);\n    }\n    \n    /**\n     * @notice Transfer tokens from contract to owner\n     * @param token Token address\n     * @param amount Amount to transfer (use MAX_UINT for entire balance)\n     */\n    function pushToken(address token, uint256 amount) external onlyOwner {\n        if (amount == MAX_UINT) {\n            amount = IERC20(token).balanceOf(address(this));\n        }\n        IERC20(token).transfer(owner, amount);\n    }\n    \n    /**\n     * @notice Get token balance of this contract\n     * @param token Token address\n     * @return balance Token balance\n     */\n    function getBalance(address token) external view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n    \n    /**\n     * @notice Simulate multicall execution\n     * @param calls Array of Call structs\n     * @return results Array of Result structs with success status and return data\n     */\n    function simulateMulticall(Call[] calldata calls) external returns (Result[] memory results) {\n        uint256 length = calls.length;\n        results = new Result[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            try this.simulateCall(calls[i].target, calls[i].callData) returns (bytes memory ret) {\n                results[i] = Result(true, ret);\n            } catch (bytes memory reason) {\n                results[i] = Result(false, reason);\n            }\n        }\n    }\n    \n    /**\n     * @notice Helper function for simulation\n     */\n    function simulateCall(address target, bytes calldata data) external returns (bytes memory) {\n        (bool success, bytes memory ret) = target.call(data);\n        if (!success) {\n            assembly {\n                revert(add(ret, 32), mload(ret))\n            }\n        }\n        return ret;\n    }\n    \n    // Internal functions\n    function _approveIfNeeded(address token, address spender, uint256 amount) private {\n        uint256 currentAllowance = IERC20(token).allowance(address(this), spender);\n        if (currentAllowance < amount) {\n            // Reset approval to 0 first for tokens that require it\n            if (currentAllowance > 0) {\n                IERC20(token).approve(spender, 0);\n            }\n            IERC20(token).approve(spender, amount == MAX_UINT ? MAX_UINT : amount);\n        }\n    }\n    \n    function _getRevertMsg(bytes memory returnData) private pure returns (string memory) {\n        if (returnData.length < 68) return \"Transaction reverted silently\";\n        \n        assembly {\n            returnData := add(returnData, 0x04)\n        }\n        return abi.decode(returnData, (string));\n    }\n    \n    function _toString(uint256 value) private pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    // Emergency functions\n    function rescueToken(address token, uint256 amount) external onlyOwner {\n        if (amount == MAX_UINT) {\n            amount = IERC20(token).balanceOf(address(this));\n        }\n        IERC20(token).transfer(owner, amount);\n    }\n    \n    function rescueETH() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n    \n    // Receive ETH\n    receive() external payable {}\n}",
  "constructor_args": {
    "owner": "0x91c612a37b8365C2db937388d7b424fe03D62850"
  }
}